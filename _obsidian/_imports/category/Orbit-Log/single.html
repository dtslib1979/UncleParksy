<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Parksy Automation OS Whitepaper</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #050509;
      color: #9ca3af;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.7;
    }
    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }
    .page-header {
      margin-bottom: 20px;
    }
    .brand-title {
      font-size: 1.6rem;
      font-weight: 700;
      color: #ffffff;
    }
    .brand-subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-top: 4px;
    }
    .media-links {
      margin-top: 16px;
    }
    .btn-media {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 18px;
      border-radius: 9999px;
      border: 1px solid #4b5563;
      text-decoration: none;
      color: #e5e7eb;
      font-size: 0.9rem;
      box-shadow: 0 0 8px rgba(148, 163, 184, 0.25);
      background: radial-gradient(circle at top left, rgba(249, 250, 251, 0.06), transparent);
    }
    .btn-media:hover {
      border-color: #9ca3af;
      box-shadow: 0 0 12px rgba(209, 213, 219, 0.35);
    }
    .media-embed {
      margin-bottom: 28px;
    }
    .media-frame {
      position: relative;
      width: 100%;
      padding-top: 56.25%;
      overflow: hidden;
      border-radius: 16px;
      background: #000;
    }
    .media-frame iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }
    .accordion {
      margin-top: 12px;
    }
    .accordion-item {
      margin-bottom: 16px;
      border-radius: 16px;
      overflow: hidden;
      background: #0b0c10;
      border: 1px solid #111827;
    }
    .accordion-header {
      width: 100%;
      background: #0f172a;
      color: #e5e7eb;
      border: none;
      outline: none;
      cursor: pointer;
      padding: 14px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.98rem;
    }
    .accordion-header:hover {
      background: #111827;
    }
    .accordion-icon {
      font-weight: 700;
      transition: transform 0.3s ease;
    }
    .accordion-item.is-open .accordion-icon {
      transform: rotate(45deg);
    }
    .accordion-content {
      max-height: 0;
      overflow: hidden;
      background: #05060a;
      padding: 0 18px;
      transition: max-height 0.35s ease;
    }
    .accordion-item.is-open .accordion-content {
      padding: 16px 18px 18px;
    }
    .highlight {
      color: #ffffff;
      font-weight: 600;
      margin: 8px 0 14px;
      font-size: 0.98rem;
    }
    .highlight .ko,
    .highlight .en {
      display: block;
    }
    .highlight .en {
      opacity: 0.9;
      font-weight: 500;
    }
    .body-ko {
      font-size: 0.92rem;
      color: #9ca3af;
      white-space: normal;
    }
    .key {
      font-weight: 600;
      color: #e5e7eb;
    }
    @media (min-width: 768px) {
      .brand-title {
        font-size: 1.8rem;
      }
      .accordion-header {
        font-size: 1rem;
      }
      .body-ko {
        font-size: 0.95rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="page-header">
      <div class="brand">
        <div class="brand-title">Parksy Automation OS</div>
        <div class="brand-subtitle">LLM × GitHub × Mobile × MCP · 1인 창작 공장 시스템</div>
      </div>
      <div class="media-links">
        <a class="btn-media btn-youtube" href="https://youtu.be/gA2ncksdHRk?si=8J4rojwVRZQQf1RS">▶ YouTube</a>
      </div>
    </header>

    <div class="media-embed">
      <div class="media-frame">
        <iframe
          src="https://www.youtube.com/embed/gA2ncksdHRk?autoplay=1&mute=1&playsinline=1&rel=0&start=0.1"
          title="YouTube video player"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          allowfullscreen
          loading="lazy"
        ></iframe>
      </div>
    </div>

    <div class="accordion">

      <!-- 섹션 1: 출발점 -->
      <div class="accordion-item is-open">
        <button class="accordion-header">
          <span class="accordion-title">1. 출발점 · Seed of Parksy OS</span>
          <span class="accordion-icon">+</span>
        </button>
        <div class="accordion-content">
          <p class="highlight">
            <span class="ko">키워드 한 줄 요약: 말 → 구조화 → 코드/액션 → 빌드 → 출판 → 루프.</span>
            <span class="en">One-line loop: Speech → Structure → Code/Action → Build → Publish → Loop.</span>
          </p>
          <p class="highlight">
            <span class="ko">“그냥 물어보니까 코드까지 다 짜준다?”에서 이 모든 프로젝트가 시작됐다.</span>
            <span class="en">The whole project began from: “I just ask, and it even writes the code for me?”</span>
          </p>
          <p class="body-ko">
📘 Parksy Automation OS Whitepaper<br><br>
— LLM × GitHub × Mobile × MCP로 만드는 1인 창작 공장 시스템 (최종판)<br><br>
키워드 한 줄 요약 말 → 구조화 → 코드/액션 → 빌드 → 출판 → 루프<br><br>
1. 출발점: “말만 해서 시스템까지 가고 싶다”<br><br><br>
1-1. 첫 번째 충격: LLM의 코드 생성 능력<br><br>
처음 시작은 단순했다.<br><br>
“그냥 물어보니까 코드까지 다 짜준다?”<br><br>
텍스트 답변을 넘어서:<br><br>
파이썬 스크립트<br><br>
웹 코드<br><br>
아키텍처 설명<br><br>
자동화 흐름까지 설명 가능<br><br>
여기서 생긴 기본 욕망:<br><br>
“내가 말만 하면, 코드·문서·공장·출판까지 한 번에 이어지게 만들 수 있겠는데?”<br><br>
이게 Parksy OS / EduArt Engineer 프로젝트의 씨앗.<br><br>
1-2. 두 번째 충격: Claude MCP Desktop = PC 원격 기계 감독<br><br>
ChatGPT가 “머리”를 대체한다면, Claude MCP는 “손발+근육+공장 로봇”을 장착해버렸다.<br><br>
로컬 파일 읽기/쓰기<br><br>
ffmpeg 실행<br><br>
파이썬 코드 실행<br><br>
Node 설치/빌드<br><br>
Git 커밋/푸시 자동화<br><br>
폴더 구조 생성/리팩토링<br><br>
심지어 APK 빌드까지 가능<br><br>
이걸 보고 나온 결론:<br><br>
“PC는 이제 ‘내가 만지는 컴퓨터’가 아니라, 클로드가 대신 굴리는 자동화 공장이다.”<br><br>
1-3. 세 번째 발견: GitHub = 출판사 + 코드 공장 본체<br><br>
GitHub를 단순 저장소로 보지 않고 이렇게 보게 됨:<br><br>
콘텐츠 저장소: MDX, HTML, 이미지, 데이터<br><br>
출판사: GitHub Pages<br><br>
빌드/배포 시스템: GitHub Actions<br><br>
템플릿/표준화 센터: 레포 구조<br><br>
즉,<br><br>
“GitHub = 내 전체 생태계의 ‘본사 & 출판사 & 코드 공장’”<br><br>
이 인식 전환이 지금 시스템의 핵심.
          </p>
        </div>
      </div>

      <!-- 섹션 2: 중간에서 부딪힌 벽들 -->
      <div class="accordion-item">
        <button class="accordion-header">
          <span class="accordion-title">2. 중간에서 부딪힌 벽들 · Failures & Frictions</span>
          <span class="accordion-icon">+</span>
        </button>
        <div class="accordion-content">
          <p class="highlight">
            <span class="ko">폰은 중심이지만, 대형 공장 작업은 PC가 필요하다는 걸 인정하게 됐다.</span>
            <span class="en">The phone stays central, but heavy factory work must live on the PC.</span>
          </p>
          <p class="body-ko">
1. 중간에서 부딪힌 벽들 (실패와 혼란)<br><br><br>
2-1. “모바일에서 전부 한다” 시도<br><br>
초기 목표:<br><br>
인샷 대체도 폰에서<br><br>
PWA도 폰에서<br><br>
GitHub도 폰에서<br><br>
심지어 거의 모든 편집/출판까지 폰에서<br><br>
하지만 현실은:<br><br>
ffmpeg 대량 처리 → 모바일에서 비현실적<br><br>
Node/파이썬/Docker 빌드 → 사실상 PC 필수<br><br>
MCP(로컬 제어)는 모바일에서 잘 안 됨<br><br>
APK 빌드/디버깅 → PC 환경이 훨씬 필요<br><br>
핵심:<br><br>
“폰은 중심이지만, 대형 공장 작업은 PC가 필요하다”는 걸 인정하게 됨.<br><br>
2-2. PWA로 인샷 대체하려다 깨진 지점<br><br>
당초 플랜:<br><br>
“인샷 반복 편집 대신, Vercel + PWA로 클라우드 인샷을 만들자.”<br><br>
문제:<br><br>
Vercel Serverless Function에는 시간 제한이 있음<br><br>
Hobby / Free: 수 초 수준<br><br>
Pro: 그래도 60초 정도<br><br>
영상 인코딩, 긴 ffmpeg 작업 → 타임아웃 리스크<br><br>
폰 내부 저장소 파일에 직접 접근이 안 됨<br><br>
업로드해야만 처리 가능<br><br>
결론:<br><br>
❌ 긴 영상/대량편집/폰 로컬 파일 직통 처리는 PWA/Vercel 조합만으로는 한계가 있다.<br><br>
2-3. GitHub / Vercel / 도메인 / PWA 혼선기<br><br>
한때 상태:<br><br>
GitHub Pages<br><br>
Vercel<br><br>
Tistory / WordPress / 도메인<br><br>
PWA 레포 따로<br><br>
Apps 레포 따로<br><br>
이 모든 게 직관 없이 섞여서 혼란스러웠던 시기가 있었음.<br><br>
지금은:<br><br>
도메인 역할 분리 (parksy.kr / eae.kr / dtslib.com)<br><br>
레포 슬롯 7개 고정<br><br>
GitOps 기반으로 어느 정도 정리 완료.<br><br>
이 백서는 그 “정리된 상태”를 기준으로 씀.
          </p>
        </div>
      </div>

      <!-- 섹션 3: 최종 인식 · 역할을 명확히 -->
      <div class="accordion-item">
        <button class="accordion-header">
          <span class="accordion-title">3. 최종 인식 · Role Separation</span>
          <span class="accordion-icon">+</span>
        </button>
        <div class="accordion-content">
          <p class="highlight">
            <span class="ko">핵심 키워드는 “누가 / 어디서 / 무엇을 / 어떻게 돌리냐”이다.</span>
            <span class="en">The core question is: “Who runs what, where, and how?”</span>
          </p>
          <p class="body-ko">
1. 최종 인식: 역할을 명확히 나누자<br><br><br>
핵심 키워드: “누가 / 어디서 / 무엇을 / 어떻게 돌리냐”<br><br>
네 가지 축으로 나눌 수 있다.<br><br>
1. 장치(디바이스)<br><br><br>
폰<br><br>
PC<br><br>
1. 플랫폼<br><br><br>
GitHub<br><br>
Vercel<br><br>
YouTube / SNS<br><br>
1. AI 에이전트<br><br><br>
ChatGPT<br><br>
Claude MCP<br><br>
Grok<br><br>
GitHub Copilot Agents<br><br>
1. 아티팩트(결과물)<br><br><br>
MDX / HTML / 웹페이지<br><br>
PWA / APK<br><br>
영상 / 음원 / 이미지<br><br>
백서 / 튜토리얼 / 교재
          </p>
        </div>
      </div>

      <!-- 섹션 4: 각 요소의 정확한 역할 정의 -->
      <div class="accordion-item">
        <button class="accordion-header">
          <span class="accordion-title">4. 각 요소의 정확한 역할 정의</span>
          <span class="accordion-icon">+</span>
        </button>
        <div class="accordion-content">
          <p class="highlight">
            <span class="ko">폰은 왕이고, PC는 공장이고, GitHub는 본사이자 출판사다.</span>
            <span class="en">The phone is king, the PC is the factory, and GitHub is both HQ and publisher.</span>
          </p>
          <p class="body-ko">
1. 각 요소의 ‘정확한 역할 정의’<br><br><br>
4-1. 폰 (Galaxy / Mobile) = 메인 콘솔 + 생산·소비 단말<br><br>
폰에서 하는 일:<br><br>
STT로 말 던지기 (삼성 키보드)<br><br>
ChatGPT에 발화 → 기획/설계/정리<br><br>
GitHub 앱/웹으로:<br><br>
코드/MDX/HTML 간단 수정<br><br>
Actions 모니터링 및 재시도<br><br>
브랜치/커밋 관리(간단 수준)<br><br>
Vercel 대시보드 확인<br><br>
PWA 설치/테스트<br><br>
YouTube/인스타/스레드 업로드<br><br>
아티팩트(완성된 영상/페이지/앱)를 직접 사용<br><br>
핵심:<br><br>
“폰은 왕이다. 명령 내리고, 결과를 보고, 배포하고, 소비한다.”<br><br>
4-2. PC + Claude MCP Desktop = 중공업 공장 + 수술실<br><br>
PC에서, Claude MCP가 하는 일:<br><br>
파이썬 / ffmpeg 자동화 스크립트 실행<br><br>
MIDI → AIVA → 음원 → 영상 병합 공장 설계 및 실행<br><br>
GitHub 레포 로컬 클론 → 대규모 리팩토링<br><br>
Node/Next.js 앱 설치/빌드/테스트<br><br>
APK 빌드 (React Native / Flutter 등)<br><br>
GitHub Actions용 yml 템플릿 생성<br><br>
DevOps 수준 자동화:<br><br>
CI/CD 파이프라인<br><br>
이미지/영상 일괄 변환<br><br>
대용량 작업(batch) 오케스트레이션<br><br>
정리하면:<br><br>
“PC는 공장, Claude는 수술하는 공장장” 사람(박씨)은 그 위에서 구상·명령만 내린다.<br><br>
4-3. GitHub = 본사 + 출판사 + GitOps 허브<br><br>
GitHub 역할:<br><br>
1. 콘텐츠 저장소<br><br><br>
MDX, HTML, JSON, 이미지, 메타데이터<br><br>
1. 출판사 (GitHub Pages)<br><br><br>
MDX/HTML 수정 → Actions → 빌드 → 즉시 반영<br><br>
parksy.kr / eae.kr / dtslib.com 의 핵심 뼈대<br><br>
1. 자동화 허브 (Actions)<br><br><br>
커밋 → 빌드 → 테스트 → 배포<br><br>
Pages / Vercel / 기타 워크플로우 모두 여기서 트리거<br><br>
1. 템플릿/표준 구조<br><br><br>
7개 슬롯 레포<br><br>
공통 보일러플레이트<br><br>
PWA/MDX/튜토리얼 템플릿<br><br>
여기서 중요한 포인트 하나:<br><br>
GitHub Actions는 모바일에서도 충분히 수정·트리거 가능 (지금 실제로 그렇게 사용 중) 다만,<br><br>
로컬에서 동일 환경 재현 (예: act)<br><br>
대형 빌드/디버깅 이런 건 PC+Claude 쪽이 훨씬 편하고 안정적일 뿐.<br><br>
4-4. Vercel = 앱·유틸·경량 백엔드 스튜디오<br><br>
Vercel에서 하는 일:<br><br>
Next.js 기반 PWA/웹앱 배포<br><br>
간단한 API Routes<br><br>
이미지/정적 파일 최적화<br><br>
GitHub 커밋 → 자동 빌드/배포<br><br>
(영상 인코딩처럼 무거운 건 ❌ → 백그라운드 워커나 다른 서비스로 분리)<br><br>
박씨 기준으로는:<br><br>
“Vercel은 GitHub 기반 앱을 세상에 내보내는 스튜디오”<br><br>
“폰에서 쓰는 PWA는 여기서 빌드·호스팅”<br><br>
4-5. PWA = 폰에서 돌아가는 클라우드 앱<br><br>
정리:<br><br>
설치는 폰<br><br>
실행은 폰<br><br>
데이터는 주로 클라우드 (GitHub / DB / S3 등)<br><br>
브라우저/앱 중간 지점<br><br>
PWA의 올바른 용도:<br><br>
업로드형 자동화<br><br>
폰에서 파일을 선택/업로드<br><br>
서버가 처리<br><br>
결과를 내려받음<br><br>
조회·편집형 인터페이스<br><br>
GitHub 기반 콘텐츠 조회<br><br>
가벼운 Form/데이터 입력<br><br>
태깅/분류/메모 등<br><br>
❌ PWA에게 절대로 억지로 시키지 말 것:<br><br>
폰 로컬 저장소 전체 스캔<br><br>
긴 영상 ffmpeg 인코딩<br><br>
수십 분짜리 배치 작업<br><br>
그건 PWA가 아니라 PC or APK의 영역.<br><br>
4-6. APK = 인샷 진짜 대체용 ‘온디바이스 공장 앱’<br><br>
APK(안드로이드 앱)의 강점:<br><br>
/storage/emulated/0/... 아래 폴더 접근 가능 (권한 승인 시)<br><br>
갤러리, Music, Download 폴더 등 로컬 파일 스캔 가능<br><br>
ffmpeg-kit 같은 라이브러리로 폰에서 직접 인코딩<br><br>
오프라인도 동작 가능<br><br>
“인샷처럼 생겼는데, 내 로직대로 작동하는 나만의 편집기” 가능<br><br>
역할:<br><br>
“폰 로컬에 이미 쌓여 있는 영상/음원을 업로드 없이 바로 가공하고 싶은 경우 → APK가 답이다.”<br><br>
그래서 정리:<br><br>
인샷 대체 = PWA가 아니라 APK가 본질에 더 가까움<br><br>
PWA는 “업로드 기반 자동화”,<br><br>
APK는 “로컬 기반 자동화”
          </p>
        </div>
      </div>

      <!-- 섹션 5: AI 팀 구성 -->
      <div class="accordion-item">
        <button class="accordion-header">
          <span class="accordion-title">5. AI 팀 구성 · Team of Agents</span>
          <span class="accordion-icon">+</span>
        </button>
        <div class="accordion-content">
          <p class="highlight">
            <span class="ko">1인 기업이지만, 실제로는 CTO·플래너·마케팅팀·편집부를 둔 회사 구조다.</span>
            <span class="en">It’s a one-person company that effectively has a CTO, planner, marketing squad, and editing team.</span>
          </p>
          <p class="body-ko">
4-7. AI 팀 구성: 각자 역할 확정<br><br>
🧠 ChatGPT = 두뇌 / 설계 / 정리 / 글·구조 담당<br><br>
박씨 발화 → 개념 정리 → 구조화 → 백서/튜토리얼화<br><br>
GitHub README / MDX / 설계 문서 초안 작성<br><br>
프롬프트 엔진, 프로젝트 지침서, 아키텍처 설명 문서 생성<br><br>
“생각 → 시스템 설계 도면” 변환<br><br>
🧬 Claude MCP = 외과 전문의 / 자동화 공장장<br><br>
파이썬·ffmpeg·Node·Docker·Git을 PC에서 직접 돌리는 집도의<br><br>
대량 작업, 대규모 리팩토링, 환경설치, 디버깅<br><br>
APK 빌드, 로컬 테스트, GitHub 연동 배치 작업 전담<br><br>
🎭 Grok = 밈·캠페인·트렌드 담당<br><br>
MZ 감성, 짧은 카피, 쇼츠용 문구, 캠페인 문장<br><br>
트위터식 짧은 임팩트 있는 문장 뽑기<br><br>
“이걸 어떻게 요즘 애들 언어로 팔아먹을까?” 담당<br><br>
🧰 GitHub Copilot Agents = 출판물 편집부(알바팀)<br><br>
GitHub 레포 내부에서:<br><br>
MDX 수정<br><br>
CSS/디자인 마이너 변경<br><br>
카테고리 구조 정리<br><br>
import 경로 정리<br><br>
죽은 링크 제거<br><br>
작은 코드 리팩토링<br><br>
즉, “GitHub Pages라는 출판물을 매일 조금씩 손보는 편집 알바팀”
          </p>
        </div>
      </div>

      <!-- 섹션 6: 전체 플로우 -->
      <div class="accordion-item">
        <button class="accordion-header">
          <span class="accordion-title">6. 전체 플로우 · Speech → GitOps → 출판</span>
          <span class="accordion-icon">+</span>
        </button>
        <div class="accordion-content">
          <p class="highlight">
            <span class="ko">말하면 기록되고, 기록되면 빌드되고, 빌드되면 퍼블리시된다.</span>
            <span class="en">If you speak, it’s recorded; if recorded, it’s built; once built, it’s published.</span>
          </p>
          <p class="body-ko">
1. 전체 플로우: “말 → GitOps → 출판 → 유통”<br><br><br>
5-1. 기본 루프 (콘텐츠/백서/튜토리얼)<br><br>
1. 말한다<br><br><br>
폰에서 STT로 떠듦 → ChatGPT 스레드<br><br>
1. ChatGPT가 구조화<br><br><br>
개념 정리<br><br>
섹션 나누기<br><br>
표/구조화<br><br>
MDX 템플릿에 맞게 가공<br><br>
1. GitHub로 간다<br><br><br>
MDX/Markdown/HTML로 저장<br><br>
커밋/푸시<br><br>
1. GitHub Actions가 돈다<br><br><br>
빌드 시작<br><br>
에러 있으면 로그 확인 → 수정 → 재빌드<br><br>
1. GitHub Pages / Vercel에 출판<br><br><br>
웹페이지/앱 형태로 세상에 노출<br><br>
1. 필요시 Copilot Agents가 다듬기<br><br><br>
스타일/디자인/카테고리/링크 정리<br><br>
1. 폰에서 최종 소비 & 배포<br><br><br>
폰 브라우저/PWA로 확인<br><br>
필요하면 YouTube/인스타/스레드/블로그에 재배포<br><br>
5-2. 영상/음원/쇼츠 루프 (인샷 대체 라인)<br><br>
1. 소스 수집<br><br><br>
MIDI 다운로드 (PC or 폰)<br><br>
이미 만들어 둔 이미지/영상 유닛 (폰/클라우드)<br><br>
1. PC + Claude 공장<br><br><br>
파이썬 + ffmpeg 공장 (120곡 등)<br><br>
규칙대로:<br><br>
음원 + 영상 매칭<br><br>
개별 클립 생성<br><br>
concat으로 긴 버전 생성<br><br>
1. 결과물 전달<br><br><br>
GitHub, Google Drive, S3 등<br><br>
또는 폰으로 직접 복사<br><br>
1. 폰/APK/PWA에서 활용<br><br><br>
APK: 로컬 클립 재조합, 추가 편집<br><br>
PWA: 업로드 기반 클라우드 편집 (가벼운 용도)<br><br>
YouTube 쇼츠/롱폼 업로드<br><br>
핵심:<br><br>
긴·대량 공정 = PC+클로드 공장 쇼츠 단위 조합/배포 = 폰 & APK & PWA & YouTube<br><br>
1. 이 전체 시스템이 의미하는 것<br><br><br>
6-1. 기술적인 의미<br><br>
GitOps 기반 1인 창작 공장<br><br>
디바이스 역할 분리: 폰(명령/소비) vs PC(공장)<br><br>
AI 팀 오케스트레이션:<br><br>
ChatGPT(설계)<br><br>
Claude(실행)<br><br>
Copilot(편집)<br><br>
Grok(캠페인)<br><br>
PWA vs APK 역할 정리<br><br>
업로드 기반 vs 로컬 기반 자동화<br><br>
6-2. 창작/비즈니스적인 의미<br><br>
인샷/편집노동 → 시스템으로 치환<br><br>
백서/튜토리얼/세계관/웹툰/쇼츠 전부 **“말 → 구조화 → 코드/액션 → 출판”**으로 묶임<br><br>
1인 기업이지만, 실제론:<br><br>
CTO (Claude)<br><br>
CCO/플래너 (ChatGPT)<br><br>
마케팅 팀 (Grok)<br><br>
편집부 (Copilot) 를 둔 회사와 비슷한 구조<br><br>
1.     <br><br>
최종 3원칙 (Parksy Automation OS Core Principles)<br><br>
2.     <br><br>
말하면 기록된다.<br><br>
STT → LLM → GitHub<br><br>
대충 말해도 구조화는 시스템이 한다.<br><br>
1. 기록되면 빌드된다.<br><br><br>
GitHub 커밋 → Actions → 빌드 → 출판<br><br>
사람은 버튼 누르고, 에러나면 방향만 잡는다.<br><br>
1. 빌드되면 퍼블리시된다.<br><br><br>
Pages / PWA / APK / YouTube / SNS<br><br>
결과물은 자동으로 여러 채널에 퍼져 나간다.
          </p>
        </div>
      </div>

    </div>
  </div>

  <script>
    document.querySelectorAll('.accordion-header').forEach(header => {
      header.addEventListener('click', () => {
        const item = header.parentElement;
        const content = item.querySelector('.accordion-content');
        const isOpen = item.classList.contains('is-open');

        if (isOpen) {
          item.classList.remove('is-open');
          content.style.maxHeight = 0;
        } else {
          item.classList.add('is-open');
          content.style.maxHeight = content.scrollHeight + 'px';
        }
      });
    });

    document.querySelectorAll('.accordion-item.is-open .accordion-content').forEach(content => {
      content.style.maxHeight = content.scrollHeight + 'px';
    });
  </script>
</body>
</html>